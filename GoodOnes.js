/*
	advanced_add	= higher order, arguments handling, slice call
	chunk 			= i+size
	coordinates		= cause coordinates
	countOccurances = counts occurances of array elements, (if ? true : false) notation
	flatten			= concat apply, merging two or more arrays, commonly found
	search			= arr.some (indexOf except returns value)
	symmetricalDiff = removing duplicates in an array

	cashRegister	= whileloops and numberswork
	isEven			= non-modulus(%) even/odd
	sumFibonacci	= fibonacci generation
	sumPrimes		= prime num generation, << operator
	LCM				= incomplete, but good idea
	
	findlongestword = updated recent
	friendlyDates	= switching
	letterchanges	= changing letters in a word
	
	permAlone		= permutation of word
	phoneNumber		= regex phonenumber
	pigLatin		= .substr
	spinalCase		= double regex capture
	titleCase		= commonly found
	truncate		= commonly found

	obj_flatten
	array_flatten
	modularity
	getMax
	obj_compare
	rememberArgs
*/
/* have used
recursion vs while/for

for prop in object

obj[prop] vs obj.prop

var funct =function() vs function funct(){

mutable vs immutable (strings)

shift and pop

slice vs splice
	slice is variable, splice mutates like push.

slice vs substring
	prefer slice for string and array flexibility

search vs match vs exec
	search = index of first match
	match = array of matches of regex
	exec = mulitple regex capture

indexOf vs lastIndexOf

forEach vs map vs reduce

some vs every

filter vs reject

sort function(a,b){return a>b}
	returns [a>>>>>>b]

parseInt parseFloat toFixed

call vs apply
	call = args is args, apply args is an array
	

don't forget semicolons, or uglify will hate you